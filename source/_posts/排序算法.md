---
title: 排序算法
date: 2021/10/10 22:57:00
categories:
- 排序算法
---

## 排序算法

### 排序算法的介绍

排序也称排序算法(Sort Algorithm)，排序是将**一组数据**，依**指定的顺序**进行排列的过程。

### 排序的分类：

1. 内部排序

   指将需要处理的所有数据都加载到内部存储器（内存）中排序

2. 外部排序法

   数据量过大，无法全部加载到内存中，需要借助外部存储（文件等）

3. 常见的排序算法分类

![常见的排序算法分类](/img/排序/image-20211020233551547.png)

### 算法的时间复杂度（未完成）

#### 度量一个程序(算法)执行时间的两种方法

1.  事后统计的方法

   ​		这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所 得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。

2. 事前估算的方法

   通过分析某个算法的时间复杂度来判断哪个算法更优。

### 冒泡排序

#### 基本介绍

​		冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

​		优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排 序写好后，在进行)

#### 演示冒泡过程的例子(图解)

![冒泡排序(图解](/img/排序/冒泡排序(图解))

小结：

1. 一共进行数组的大小 - 1 次的循环
2. )每一趟排序的次数在逐渐的减少
3. 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化

#### 代码实现

```java
public static void bubbleSort(int [] arr){
        // 冒泡排序 的时间复杂度 O(n^2), 自己写出
        int temp = 0; // 临时变量
        boolean flag = false; // 标识变量，表示是否进行过交换
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length - 1 - i ; j++) {
                // 如果前面的数比后面的数大，则交换
                if (arr[j] > arr[j + 1]) {
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if (!flag) { // 在一趟排序中，一次交换都没有发生过
                break;
            } else {
                flag = false; // 重置flag!!!, 进行下次判断
            }
        }
    }
```

### 选择排序

#### 基本介绍

它的基本思想是: 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

#### 选择排序实现

下面以数列{20,40,30,10,60,50}为例，演示它的选择排序过程(如下图)。

![img]/img/排序/alg-sort-select-1.jpg)

排序流程

- 第1趟: i=0。找出a[1...5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数列变化: 20,40,30,10,60,50 -- > 10,40,30,20,60,50
- 第2趟: i=1。找出a[2...5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数列变化: 10,40,30,20,60,50 -- > 10,20,30,40,60,50
- 第3趟: i=2。找出a[3...5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。
- 第4趟: i=3。找出a[4...5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。
- 第5趟: i=4。交换a[4]和a[5]的数据。 数列变化: 10,20,30,40,60,50 -- > 10,20,30,40,50,60

#### 代码实现

```java
public class SelectSort {

    public static void main(String[] args) {
        int[] arr = {101, 34, 119, 1, -1, 90, 123};
        selectSort(arr);
        System.out.println("排序后");
        System.out.println(Arrays.toString(arr));
    }


    public static void selectSort(int[] arr){
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int minVal= arr[i];
            for (int j = i+1; j < arr.length; j++) {
                if (minVal > arr[j]){// 说明假定的最小值，并不是最小
                    minVal = arr[j];
                    minIndex = j;
                }
            }
			// 将最小值，放在arr[0], 即交换
            if (minIndex != i){
                arr[minIndex] =arr[i];
                arr[i] =minVal;
            }
        }
    }
}
```



### 插入排序

#### 基本介绍

直接插入排序(Straight Insertion Sort)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程

#### 插入排序实现

下面选取直接插入排序的一个中间过程对其进行说明。假设{20,30,40,10,60,50}中的前3个数已经排列过，是有序的了；接下来对10进行排列。示意图如下:

![img](/img/LeetCode/alg-sort-insert-1.jpg)

图中将数列分为有序区和无序区。我们需要做的工作只有两个: 

(1)取出无序区中的第1个数，并找出它在有序区对应的位置。

(2)将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。

#### 代码实现

```java
import java.util.Arrays;

public class InsertSortTest {
    public static void main(String[] args) {
        int[] arr = {101, 34, 119, 1, -1, 89};
        insertSort(arr); //调用插入排序算法
        System.out.println(Arrays.toString(arr));
    }

    /**
     *
     * @param arr 待排序的数组
     */
    public static void insertSort(int[] arr){
        int insertVal = 0;
        int insertIndex = 0;

        for (int i = 1; i < arr.length; i++) {
            insertVal = arr[i];
            insertIndex = i - 1;

            // 给insertVal 找到插入的位置
            // 说明
            // 1. insertIndex >= 0 保证在给insertVal 找插入位置，不越界
            // 2. insertVal < arr[insertIndex] 待插入的数，还没有找到插入位置
            // 3. 就需要将 arr[insertIndex] 后移
            while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                arr[insertIndex+1] = arr[insertIndex];
                insertIndex--;
            }
            // 当退出while循环时，说明插入的位置找到, insertIndex + 1
            arr[insertIndex+1] = insertVal;
        }
    }
}

```

####  插入排序的时间复杂度和稳定性

##### 插入排序时间复杂度

直接插入排序的时间复杂度是O(N2)。

假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1！因此，直接插入排序的时间复杂度是O(N2)

##### 插入排序稳定性

直接插入排序是稳定的算法，它满足稳定算法的定义。

`算法稳定性` -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

### 快速排序

#### 基本介绍

它的基本思想是: 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

#### 快速排序实现

- 从数列中挑出一个基准值。

- 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。

- 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。

下面以数列a={30,40,60,10,20,50}为例，演示它的快速排序过程(如下图)。

  ![img](/img/LeetCode/alg-sort-fast-1.jpg)

上图只是给出了第1趟快速排序的流程。在第1趟中，设置x=a[i]，即x=30。

- 从"右 --> 左"查找小于x的数: 找到满足条件的数a[j]=20，此时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历。
- 从"左 --> 右"查找大于x的数: 找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历。
- 从"右 --> 左"查找小于x的数: 找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。
- 从"左 --> 右"查找大于x的数: 找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。
- 从"右 --> 左"查找小于x的数: 没有找到满足条件的数。当i>=j时，停止查找；然后将x赋值给a[i]。此趟遍历结束！

按照同样的方法，对子数列进行递归遍历。最后得到有序数组！

#### 代码实现

```java
public class QuickSortTest {
    public static void main(String[] args) {
        int i;
        int a[] = {30,40,60,10,20,50};

        System.out.printf("before sort:");
        for (i=0; i<a.length; i++)
            System.out.printf("%d ", a[i]);
        System.out.printf("\n");

        quickSort(a, 0, a.length-1);

        System.out.printf("after  sort:");
        for (i=0; i<a.length; i++)
            System.out.printf("%d ", a[i]);
        System.out.printf("\n");
    }


    /*
     * 快速排序
     *
     * 参数说明:
     *     a -- 待排序的数组
     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)
     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)
     */
    public static void quickSort(int[] a, int l ,int r){
        if (l < r){
            int i,j,x;
            i = l;
            j = r;
            x = a[i];

            while (i<j){
                while (i< j && a[j] >x){
                    j--;// 从右向左找第一个小于x的数
                }
                if (i<j){
                    a[i++] = a[j];
                }
                while (i< j && a[i] <x){
                    i++; // 从左向右找第一个大于x的数
                }
                if (i<j){
                    a[j--] = a[i];
                }
                a[i] = x;

                quickSort(a, l, i-1);
                quickSort(a, i+1, r);
            }

        }
    }
}

```

####  快速排序时间复杂度和稳定性

#####  快速排序稳定性

快速排序是不稳定的算法，它不满足稳定算法的定义。

`算法稳定性` -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

##### 快速排序时间复杂度

>快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。

这句话很好理解: 假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢? 至少lg(N+1)次，最多N次。

为什么最少是lg(N+1)次? 快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。

为什么最多是N次? 这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。
