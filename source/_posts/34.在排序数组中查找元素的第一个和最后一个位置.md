---
title: 34.在排序数组中查找元素的第一个和最后一个位置
date: 2021/10/16 22:18:00
categories:
- LeetCode
tags:
- 刷题
- 二分查找
---

## 34.在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```markdown
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```markdown
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```markdown
输入：nums = [], target = 0
输出：[-1,-1]
```

### 题解

由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。

考虑target开始和结束位置，其实我们要找的就是数组中**第一个等他target的位置**（lower）和**第一个大于Target的位置减一**（upper）

二分查找中，寻找lower即为在数组中寻找**第一个大于等于target的下标**，寻找upper即为在数组中寻找第一个**大于**target 的下标，然后将下标减一。

最后，因为target可能不存在数组中，因此我们需要重新校验我们得到两个下标，看是否符合条件，如何符合条件就返回[lower,upper]，不符合就返回[-1,-1]

### 代码

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = {-1,-1};
        int lower = lowerBound(nums,target);
        int upper = upperBound(nums,target) -1;
        if(lower == nums.length || nums[lower] != target){
            return res;
        }
        res[0] = lower;
        res[1] = upper;
        return res;
    }

    public int lowerBound(int[] nums,int target){
        int l = 0;
        int r = nums.length -1 ;
        int mid;
        while(l < r){
            mid = (l + r)/2;
            if(nums[mid] >= target){
                r =mid;
            }else{
                l = mid+1;
            }
        }
        return l;
    }

    public int upperBound(int[] nums,int target) {
        int l = 0;
        int r = nums.length;
        int mid;
         while(l < r){
            mid = (l + r)/2;
            if(nums[mid]>target){
                r =mid;
            }else{
                l = mid+1;
            }

         }
        return l;
    }

}
```

