---
title: 101.对称二叉树
date: 2021/11/23 09:41:00
categories:
- LeetCode
tags:
- 刷题
- 树
---

## 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    	1
       / \
      2   2
     / \ / \
    3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    	1
       / \
      2   2
       \   \
       3    3
### 方法（递归）

#### 题解

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。

#### 代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode p,TreeNode q){
        if(p == null && q == null){
            return true;
        }
        if(p ==null || q ==null){
            return false;
        }
        return p.val == q.val ? check(p.left,q.right) && check(p.right,q.left):false; 
    }
}
```

### 方法（迭代）

#### 题解

首先我们引入一个队列。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

#### 代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode p,TreeNode q){
         Queue<TreeNode> qu = new LinkedList<TreeNode>();
         qu.offer(p);
         qu.offer(q);
         while(!qu.isEmpty()){
             p = qu.poll();
             q = qu.poll();
             if(p == null && q == null){
                 continue;
             }
             if((q == null || p == null) || q.val != p.val ){
                 return false;
             }
             qu.offer(q.left);
             qu.offer(p.right);

             qu.offer(p.left);
             qu.offer(q.right);
         }
         return true;
    }
}
```

